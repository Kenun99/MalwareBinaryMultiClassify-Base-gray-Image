import numpy as np

# reference url: https://scikit-learn.org/stable/modules/model_evaluation.html#classification-metrics
from sklearn.metrics import confusion_matrix, precision_score, recall_score, f1_score, roc_auc_score
from sklearn.metrics import roc_curve, auc
from sklearn.metrics import classification_report
import numpy as np
import matplotlib.pyplot as plt


class Metrics:
    def __init__(self, y_true, prediction):
        self.y_true = y_true
        self.y_pred = [np.argmax(item) for item in prediction]
        self.y_score1 = prediction[:, 1]
        self.y_score0 = prediction[:, 0]

    def confusion_matrix(self):
        return confusion_matrix(y_true=self.y_true, y_pred=self.y_pred)

    def precision(self):
        return precision_score(y_true=self.y_true, y_pred=self.y_pred, average='macro')

    def recall(self):
        return recall_score(y_true=self.y_true, y_pred=self.y_pred, average='macro')

    def F_score(self):
        return f1_score(y_true=self.y_true, y_pred=self.y_pred, average='macro')

    def roc_curve(self, show=True):
        fpr, tpr, thresholds = roc_curve(y_true=self.y_true, y_score=self.y_score1)
        if show is True:
            plt.plot(fpr, tpr)
            plt.show()
        return fpr, tpr, thresholds

    def auc(self):
        fpr, tpr, threshold = self.roc_curve(show=False)
        return auc(fpr, tpr)

    def describe(self, show=False):
        print("precision=", self.precision())
        print("recall=", self.recall())
        print("F1_score=", self.F_score())

        # print("confusion_matrix:\n", self.confusion_matrix())
        if show is True:
            self.roc_curve()


def multiclass_log_loss(y_true, y_pred, eps=1e-15):
    """Multi class version of Logarithmic Loss metric.
    https://www.kaggle.com/wiki/MultiClassLogLoss
    Parameters
    ----------
    y_true : array, shape = [n_samples]
            true class, intergers in [0, n_classes - 1)
    y_pred : array, shape = [n_samples, n_classes]
    Returns
    -------
    loss : float
    """
    predictions = np.clip(y_pred, eps, 1 - eps)

    # normalize row sums to 1
    predictions /= predictions.sum(axis=1)[:, np.newaxis]

    actual = np.zeros(y_pred.shape)
    n_samples = actual.shape[0]
    actual[np.arange(n_samples), y_true.astype(int)] = 1
    vectsum = np.sum(actual * np.log(predictions))
    loss = -1.0 / n_samples * vectsum
    return loss


def print_res(target_list):
    malware_class = ["Ramnit", "Lollipop", "Kelihos_ver3", "Vundo", "Simda",
                     "Tracur", "Kelihos_ver1", "Obfuscator.ACY", "Gatak"]
    for i in range(0, 9):
        cnt = 0
        for item in target_list:
            if item == i:
                cnt += 1
        print("[+]", malware_class[i], " : ", cnt)


def plot_train(history):
    """打印出训练过程中loss的变化趋势"""
    train_loss = history['loss']
    train_acc = history['acc']
    fig = plt.figure()
    ax1 = fig.add_subplot(111)
    line1 = ax1.plot(train_loss, 'g-', label='train_loss')
    ax2 = ax1.twinx()
    line2 = ax2.plot(train_acc, 'r', label='train_acc')

    lines = line1 + line2
    labels = [line.get_label() for line in lines]
    plt.legend(lines, labels, loc='best')
    ax1.set_xlabel('epochs')
    ax1.set_ylabel('train_loss')
    ax2.set_ylabel('train_accuracy')
    plt.savefig('./train_process.png')


def multi_class_report(y_true, y_pred):
    target_names = ["Ramnit", "Lollipop", "Kelihos_ver3", "Vundo", "Simda",
                    "Tracur", "Kelihos_ver1", "Obfuscator.ACY", "Gatak"]
    print(classification_report(y_true, y_pred, target_names=target_names))
